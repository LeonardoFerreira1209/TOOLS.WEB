import {
  __publicField
} from "./chunk-KGUINB4D.js";

// node_modules/lord-icon-element/build/helpers/colors.js
var COLOURS = {
  "aliceblue": "#f0f8ff",
  "antiquewhite": "#faebd7",
  "aqua": "#00ffff",
  "aquamarine": "#7fffd4",
  "azure": "#f0ffff",
  "beige": "#f5f5dc",
  "bisque": "#ffe4c4",
  "black": "#000000",
  "blanchedalmond": "#ffebcd",
  "blue": "#0000ff",
  "blueviolet": "#8a2be2",
  "brown": "#a52a2a",
  "burlywood": "#deb887",
  "cadetblue": "#5f9ea0",
  "chartreuse": "#7fff00",
  "chocolate": "#d2691e",
  "coral": "#ff7f50",
  "cornflowerblue": "#6495ed",
  "cornsilk": "#fff8dc",
  "crimson": "#dc143c",
  "cyan": "#00ffff",
  "darkblue": "#00008b",
  "darkcyan": "#008b8b",
  "darkgoldenrod": "#b8860b",
  "darkgray": "#a9a9a9",
  "darkgreen": "#006400",
  "darkkhaki": "#bdb76b",
  "darkmagenta": "#8b008b",
  "darkolivegreen": "#556b2f",
  "darkorange": "#ff8c00",
  "darkorchid": "#9932cc",
  "darkred": "#8b0000",
  "darksalmon": "#e9967a",
  "darkseagreen": "#8fbc8f",
  "darkslateblue": "#483d8b",
  "darkslategray": "#2f4f4f",
  "darkturquoise": "#00ced1",
  "darkviolet": "#9400d3",
  "deeppink": "#ff1493",
  "deepskyblue": "#00bfff",
  "dimgray": "#696969",
  "dodgerblue": "#1e90ff",
  "firebrick": "#b22222",
  "floralwhite": "#fffaf0",
  "forestgreen": "#228b22",
  "fuchsia": "#ff00ff",
  "gainsboro": "#dcdcdc",
  "ghostwhite": "#f8f8ff",
  "gold": "#ffd700",
  "goldenrod": "#daa520",
  "gray": "#808080",
  "green": "#008000",
  "greenyellow": "#adff2f",
  "honeydew": "#f0fff0",
  "hotpink": "#ff69b4",
  "indianred ": "#cd5c5c",
  "indigo": "#4b0082",
  "ivory": "#fffff0",
  "khaki": "#f0e68c",
  "lavender": "#e6e6fa",
  "lavenderblush": "#fff0f5",
  "lawngreen": "#7cfc00",
  "lemonchiffon": "#fffacd",
  "lightblue": "#add8e6",
  "lightcoral": "#f08080",
  "lightcyan": "#e0ffff",
  "lightgoldenrodyellow": "#fafad2",
  "lightgrey": "#d3d3d3",
  "lightgreen": "#90ee90",
  "lightpink": "#ffb6c1",
  "lightsalmon": "#ffa07a",
  "lightseagreen": "#20b2aa",
  "lightskyblue": "#87cefa",
  "lightslategray": "#778899",
  "lightsteelblue": "#b0c4de",
  "lightyellow": "#ffffe0",
  "lime": "#00ff00",
  "limegreen": "#32cd32",
  "linen": "#faf0e6",
  "magenta": "#ff00ff",
  "maroon": "#800000",
  "mediumaquamarine": "#66cdaa",
  "mediumblue": "#0000cd",
  "mediumorchid": "#ba55d3",
  "mediumpurple": "#9370d8",
  "mediumseagreen": "#3cb371",
  "mediumslateblue": "#7b68ee",
  "mediumspringgreen": "#00fa9a",
  "mediumturquoise": "#48d1cc",
  "mediumvioletred": "#c71585",
  "midnightblue": "#191970",
  "mintcream": "#f5fffa",
  "mistyrose": "#ffe4e1",
  "moccasin": "#ffe4b5",
  "navajowhite": "#ffdead",
  "navy": "#000080",
  "oldlace": "#fdf5e6",
  "olive": "#808000",
  "olivedrab": "#6b8e23",
  "orange": "#ffa500",
  "orangered": "#ff4500",
  "orchid": "#da70d6",
  "palegoldenrod": "#eee8aa",
  "palegreen": "#98fb98",
  "paleturquoise": "#afeeee",
  "palevioletred": "#d87093",
  "papayawhip": "#ffefd5",
  "peachpuff": "#ffdab9",
  "peru": "#cd853f",
  "pink": "#ffc0cb",
  "plum": "#dda0dd",
  "powderblue": "#b0e0e6",
  "purple": "#800080",
  "rebeccapurple": "#663399",
  "red": "#ff0000",
  "rosybrown": "#bc8f8f",
  "royalblue": "#4169e1",
  "saddlebrown": "#8b4513",
  "salmon": "#fa8072",
  "sandybrown": "#f4a460",
  "seagreen": "#2e8b57",
  "seashell": "#fff5ee",
  "sienna": "#a0522d",
  "silver": "#c0c0c0",
  "skyblue": "#87ceeb",
  "slateblue": "#6a5acd",
  "slategray": "#708090",
  "snow": "#fffafa",
  "springgreen": "#00ff7f",
  "steelblue": "#4682b4",
  "tan": "#d2b48c",
  "teal": "#008080",
  "thistle": "#d8bfd8",
  "tomato": "#ff6347",
  "turquoise": "#40e0d0",
  "violet": "#ee82ee",
  "wheat": "#f5deb3",
  "white": "#ffffff",
  "whitesmoke": "#f5f5f5",
  "yellow": "#ffff00",
  "yellowgreen": "#9acd32"
};
function handleColor(color) {
  if (color.startsWith("#")) {
    if (color.length === 4) {
      return `#${color[1]}${color[1]}${color[2]}${color[2]}${color[3]}${color[3]}`;
    } else {
      return color;
    }
  } else {
    return COLOURS[color.toLowerCase()] || "#000000";
  }
}

// node_modules/lord-icon-element/build/helpers/utils.js
function deepClone(value) {
  return JSON.parse(JSON.stringify(value));
}
function isObjectLike(value) {
  return value !== null && typeof value === "object";
}
function has(object, path) {
  const newPath = Array.isArray(path) ? path : path.split(".");
  let current = object;
  for (const key of newPath) {
    if (!isObjectLike(current)) {
      return false;
    }
    if (!(key in current)) {
      return false;
    }
    current = current[key];
  }
  return true;
}
function get(object, path, defaultValue) {
  const newPath = Array.isArray(path) ? path : path.split(".");
  let current = object;
  for (const key of newPath) {
    if (!isObjectLike(current)) {
      return defaultValue;
    }
    if (!(key in current)) {
      return defaultValue;
    }
    current = current[key];
  }
  return current === void 0 ? defaultValue : current;
}
function set(object, path, value) {
  let current = object;
  const newPath = Array.isArray(path) ? path : path.split(".");
  for (let i = 0; i < newPath.length; ++i) {
    if (i === newPath.length - 1) {
      current[newPath[i]] = value;
    } else {
      current = current[newPath[i]];
    }
  }
}
function isNil(value) {
  return value === null || value === void 0;
}

// node_modules/lord-icon-element/build/helpers/lottie.js
var LORDICON_SCALE = 50;
function componentToHex(c) {
  var hex = c.toString(16);
  return hex.length == 1 ? "0" + hex : hex;
}
function rgbToHex(value) {
  return "#" + componentToHex(value.r) + componentToHex(value.g) + componentToHex(value.b);
}
function hexToRgb(hex) {
  let data = parseInt(hex[0] != "#" ? hex : hex.substring(1), 16);
  return {
    r: data >> 16 & 255,
    g: data >> 8 & 255,
    b: data & 255
  };
}
function toUnitVector(n) {
  return Math.round(n / 255 * 1e3) / 1e3;
}
function fromUnitVector(n) {
  return Math.round(n * 255);
}
function hexToLottieColor(hex) {
  const { r, g, b } = hexToRgb(hex);
  return [toUnitVector(r), toUnitVector(g), toUnitVector(b)];
}
function lottieColorToHex(value) {
  const color = {
    r: fromUnitVector(value[0]),
    g: fromUnitVector(value[1]),
    b: fromUnitVector(value[2])
  };
  return rgbToHex(color);
}
function allProperties(data, lottieInstance = false) {
  const result = [];
  if (!data || !data.layers) {
    return result;
  }
  for (const [layerIndex, layer] of Object.entries(data.layers)) {
    if (!layer.nm) {
      continue;
    }
    if (!layer.nm.toLowerCase().includes("change")) {
      continue;
    }
    if (!layer.ef) {
      continue;
    }
    for (const [fieldIndex, field] of Object.entries(layer.ef)) {
      const subpath = "ef.0.v.k";
      let path;
      if (lottieInstance) {
        path = `renderer.elements.${layerIndex}.effectsManager.effectElements.${fieldIndex}.effectElements.0.p.v`;
      } else {
        path = `layers.${layerIndex}.ef.${fieldIndex}.${subpath}`;
      }
      const hasValue = has(field, subpath);
      if (!hasValue) {
        continue;
      }
      const value = get(field, subpath);
      let type = "unkown";
      if (field.mn === "ADBE Color Control") {
        type = "color";
      } else if (field.mn === "ADBE Slider Control") {
        type = "slider";
      } else if (field.mn === "ADBE Point Control") {
        type = "point";
      } else if (field.mn === "ADBE Checkbox Control") {
        type = "checkbox";
      }
      if (type === "unkown") {
        continue;
      }
      const name = field.nm;
      result.push({
        name,
        path,
        value,
        type
      });
    }
  }
  return result;
}
function resetColor(data, properties, name) {
  for (const field of properties) {
    if (field.type !== "color" || field.name.toLowerCase() !== name.toLowerCase()) {
      continue;
    }
    set(data, field.path, field.value);
  }
}
function updateColor(data, properties, name, value) {
  for (const field of properties) {
    if (field.type !== "color" || field.name.toLowerCase() !== name.toLowerCase()) {
      continue;
    }
    if (typeof value === "object") {
      if ("r" in value && "g" in value && "b" in value) {
        set(data, field.path, [toUnitVector(value.r), toUnitVector(value.g), toUnitVector(value.b)]);
      } else if (Array.isArray(value)) {
        set(data, field.path, value);
      }
    } else if (typeof value === "string") {
      set(data, field.path, hexToLottieColor(handleColor(value)));
    }
  }
}
function resetColors(data, properties) {
  for (const field of properties) {
    if (field.type !== "color") {
      continue;
    }
    set(data, field.path, field.value);
  }
}
function updateColors(data, properties, colors) {
  const parsedColors = colors.split(",");
  if (parsedColors.length) {
    for (const color of parsedColors) {
      const parts = color.split(":");
      if (parts.length !== 2) {
        continue;
      }
      for (const field of properties) {
        if (field.type !== "color") {
          continue;
        }
        if (field.name.toLowerCase() === parts[0].toLowerCase()) {
          set(data, field.path, hexToLottieColor(handleColor(parts[1])));
        }
      }
    }
  }
}
function resetProperty(data, properties, name, extraPath) {
  for (const field of properties) {
    if (field.name.toLowerCase() !== name.toLowerCase()) {
      continue;
    }
    if (extraPath) {
      set(data, field.path + `.${extraPath}`, get(field.value, extraPath));
    } else {
      set(data, field.path, field.value);
    }
  }
}
function updateProperty(data, properties, name, value, extraPath) {
  for (const field of properties) {
    if (field.name.toLowerCase() !== name.toLowerCase()) {
      continue;
    }
    const newPath = field.path + (extraPath ? `.${extraPath}` : "");
    let ratio = 1;
    if (field.type === "slider") {
      ratio = field.value / LORDICON_SCALE;
    } else if (field.type === "point") {
      ratio = (field.value[0] + field.value[1]) / 2 / LORDICON_SCALE;
    }
    set(data, newPath, value * ratio);
  }
}
function replaceProperty(data, properties, name, value, extraPath) {
  for (const field of properties) {
    if (field.name.toLowerCase() !== name.toLowerCase()) {
      continue;
    }
    const newPath = field.path + (extraPath ? `.${extraPath}` : "");
    set(data, newPath, value);
  }
}
function iconFeatures(data) {
  if (data && data.features && Array.isArray(data.features)) {
    return data.features;
  }
  return [];
}

// node_modules/lord-icon-element/build/main/manager.js
var LOTTIE_ANIMATION_LOADER;
var INSTANCES = /* @__PURE__ */ new Set();
var TRIGGERS = /* @__PURE__ */ new Map();
var ICONS = /* @__PURE__ */ new Map();
var LOADING = /* @__PURE__ */ new Map();
function registerIcon(name, iconData) {
  ICONS.set(name, iconData);
  for (const instance of INSTANCES) {
    instance.notify(name, "icon");
  }
}
function registerTrigger(name, triggerClass) {
  TRIGGERS.set(name, triggerClass);
  for (const instance of INSTANCES) {
    instance.notify(name, "trigger");
  }
}
function registerAnimationLoader(animationLoader) {
  LOTTIE_ANIMATION_LOADER = animationLoader;
}
function connectInstance(element) {
  INSTANCES.add(element);
}
function disconnectInstance(element) {
  INSTANCES.delete(element);
}
function getIcon(name) {
  return ICONS.get(name);
}
function getTrigger(name) {
  return TRIGGERS.get(name);
}
async function loadIconData(url) {
  const response = await fetch(url);
  return await response.json();
}
async function loadIcon(url) {
  if (ICONS.has(url)) {
    return;
  }
  const current = LOADING.get(url);
  if (current) {
    await current;
    return;
  }
  if (current === void 0) {
    const promise = loadIconData(url);
    LOADING.set(url, promise);
    const data = await promise;
    LOADING.delete(url);
    ICONS.set(url, data);
  }
}
function loadLottieAnimation(params) {
  if (!LOTTIE_ANIMATION_LOADER) {
    throw new Error("Unregistered Lottie.");
  }
  return LOTTIE_ANIMATION_LOADER(params);
}

// node_modules/lord-icon-element/build/global.js
var VERSION = "3.4.0";

// node_modules/lord-icon-element/build/main/element.js
var PROGRESSIVE_LOAD = false;
var STATE_PREFIX = "State-";
var SUPPORTS_ADOPTING_STYLE_SHEETS = "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var ELEMENT_STYLE = `
    :host {
      display: inline-flex;
      width: 32px;
      height: 32px;
      align-items: center;
      justify-content: center;
      position: relative;
      vertical-align: middle;
      overflow: hidden;
    }

    :host(.current-color) svg path[fill] {
      fill: currentColor;
    }

    :host(.current-color) svg path[stroke] {
      stroke: currentColor;
    }

    :host(:not(.current-color)) svg .primary path[fill] {
      fill: var(--lord-icon-primary, var(--lord-icon-primary-base));
    }

    :host(:not(.current-color)) svg .primary path[stroke] {
      stroke: var(--lord-icon-primary, var(--lord-icon-primary-base));
    }

    :host(:not(.current-color)) svg .secondary path[fill] {
      fill: var(--lord-icon-secondary, var(--lord-icon-secondary-base));
    }

    :host(:not(.current-color)) svg .secondary path[stroke] {
      stroke: var(--lord-icon-secondary, var(--lord-icon-secondary-base));
    }

    svg {
      pointer-events: none;
      display: block;
    }

    div {
      width: 100%;
      height: 100%;
    }

    div.slot {
      position: absolute;
      left: 0;
      top: 0;
      z-index: 2;
    }
`;
var styleSheet;
var OBSERVED_ATTRIBUTES = [
  "colors",
  "src",
  "icon",
  "state",
  "trigger",
  "speed",
  "stroke",
  "scale",
  "axis-x",
  "axis-y"
];
var Element = class extends HTMLElement {
  constructor() {
    super();
    __publicField(this, "_root");
    __publicField(this, "_isReady", false);
    __publicField(this, "_lottie");
    __publicField(this, "_properties");
    __publicField(this, "_connectedTrigger");
    __publicField(this, "_storedIconData");
    __publicField(this, "_palette");
    this._root = this.attachShadow({
      mode: "open"
    });
  }
  static registerAnimationLoader(animationLoader) {
    registerAnimationLoader(animationLoader);
  }
  static registerIcon(name, iconData) {
    registerIcon(name, iconData);
  }
  static registerTrigger(name, triggerClass) {
    registerTrigger(name, triggerClass);
  }
  static get observedAttributes() {
    return OBSERVED_ATTRIBUTES;
  }
  static get version() {
    return VERSION;
  }
  connectedCallback() {
    connectInstance(this);
    if (!this._isReady) {
      this.init();
    }
  }
  disconnectedCallback() {
    this.unregisterLottie();
    disconnectInstance(this);
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === "axis-x") {
      this.axisXChanged();
    } else if (name === "axis-y") {
      this.axisYChanged();
    } else {
      const method = this[`${name}Changed`];
      if (method) {
        method.call(this);
      }
    }
  }
  init() {
    if (this._isReady) {
      return;
    }
    this._isReady = true;
    if (SUPPORTS_ADOPTING_STYLE_SHEETS) {
      if (!styleSheet) {
        styleSheet = new CSSStyleSheet();
        styleSheet.replaceSync(ELEMENT_STYLE);
      }
      this._root.adoptedStyleSheets = [styleSheet];
    } else {
      const style = document.createElement("style");
      style.innerHTML = ELEMENT_STYLE;
      this._root.appendChild(style);
    }
    const slotContainer = document.createElement("div");
    slotContainer.innerHTML = "<slot></slot>";
    slotContainer.classList.add("slot");
    this._root.appendChild(slotContainer);
    const container = document.createElement("div");
    container.classList.add("body");
    this._root.appendChild(container);
    this.registerLottie();
  }
  registerLottie() {
    let iconData = this.iconData;
    if (!iconData) {
      return;
    }
    this._lottie = loadLottieAnimation({
      container: this.container,
      renderer: "svg",
      loop: false,
      autoplay: false,
      animationData: deepClone(iconData),
      rendererSettings: {
        preserveAspectRatio: "xMidYMid meet",
        progressiveLoad: PROGRESSIVE_LOAD,
        hideOnTransparent: true
      }
    });
    if (this.state || this.colors || this.stroke || this.scale || this.axisX || this.axisY) {
      const properties = this.properties;
      if (properties) {
        if (this.colors) {
          updateColors(this._lottie, properties, this.colors);
        }
        if (this.state) {
          for (const state of this.states) {
            replaceProperty(this._lottie, properties, STATE_PREFIX + state, 0);
          }
          replaceProperty(this._lottie, properties, STATE_PREFIX + this.state, 1);
        }
        if (this.stroke) {
          updateProperty(this._lottie, properties, "stroke", this.stroke);
        }
        if (this.scale) {
          updateProperty(this._lottie, properties, "scale", this.scale);
        }
        if (this.axisX) {
          updateProperty(this._lottie, properties, "axis", this.axisX, "0");
        }
        if (this.axisY) {
          updateProperty(this._lottie, properties, "axis", this.axisY, "1");
        }
        this._lottie.renderer.renderFrame(null);
      }
    }
    this._lottie.setSpeed(this.animationSpeed);
    this._lottie.addEventListener("complete", () => {
      this.dispatchEvent(new CustomEvent("animation-complete"));
    });
    this.triggerChanged();
    this.dispatchEvent(new CustomEvent("icon-ready"));
    if (iconFeatures(iconData).includes("css-variables")) {
      this.movePaletteToCssVariables();
    }
  }
  unregisterLottie() {
    this._properties = void 0;
    if (this._connectedTrigger) {
      this._connectedTrigger.disconnectedCallback();
      this._connectedTrigger = void 0;
    }
    if (this._lottie) {
      this._lottie.destroy();
      this._lottie = void 0;
      this.container.innerHTML = "";
    }
  }
  refresh() {
    var _a;
    (_a = this._lottie) == null ? void 0 : _a.renderer.renderFrame(null);
    this.movePaletteToCssVariables();
  }
  notify(name, from) {
    if (this[from] !== name) {
      return;
    }
    if (from === "icon") {
      if (this._lottie) {
        this.unregisterLottie();
      }
      this.registerLottie();
    } else if (from === "trigger" && !this._connectedTrigger) {
      this.triggerChanged();
    }
  }
  triggerChanged() {
    if (this._connectedTrigger) {
      this._connectedTrigger.disconnectedCallback();
      this._connectedTrigger = void 0;
    }
    if (this.trigger && this._lottie) {
      const TriggerClass = getTrigger(this.trigger);
      if (TriggerClass) {
        this._connectedTrigger = new TriggerClass(this, this._lottie);
        this._connectedTrigger.connectedCallback();
      }
    }
  }
  colorsChanged() {
    if (!this._isReady || !this.properties) {
      return;
    }
    if (this.colors) {
      updateColors(this._lottie, this.properties, this.colors);
    } else {
      resetColors(this._lottie, this.properties);
    }
    this.refresh();
  }
  strokeChanged() {
    if (!this._isReady || !this.properties) {
      return;
    }
    if (isNil(this.stroke)) {
      resetProperty(this._lottie, this.properties, "stroke");
    } else {
      updateProperty(this._lottie, this.properties, "stroke", this.stroke);
    }
    this.refresh();
  }
  stateChanged() {
    if (!this._isReady || !this.properties) {
      return;
    }
    if (this.state) {
      for (const state of this.states) {
        replaceProperty(this._lottie, this.properties, STATE_PREFIX + state, 0);
      }
      replaceProperty(this._lottie, this.properties, STATE_PREFIX + this.state, 1);
    } else {
      for (const state of this.states) {
        resetProperty(this._lottie, this.properties, STATE_PREFIX + state);
      }
    }
    this.refresh();
  }
  scaleChanged() {
    if (!this._isReady || !this.properties) {
      return;
    }
    if (isNil(this.scale)) {
      resetProperty(this._lottie, this.properties, "scale");
    } else {
      updateProperty(this._lottie, this.properties, "scale", this.scale);
    }
    this.refresh();
  }
  axisXChanged() {
    if (!this._isReady || !this.properties) {
      return;
    }
    if (isNil(this.axisX)) {
      resetProperty(this._lottie, this.properties, "axis", "0");
    } else {
      updateProperty(this._lottie, this.properties, "axis", this.axisX, "0");
    }
    this.refresh();
  }
  axisYChanged() {
    if (!this._isReady || !this.properties) {
      return;
    }
    if (isNil(this.axisY)) {
      resetProperty(this._lottie, this.properties, "axis", "1");
    } else {
      updateProperty(this._lottie, this.properties, "axis", this.axisY, "1");
    }
    this.refresh();
  }
  speedChanged() {
    if (this._lottie) {
      this._lottie.setSpeed(this.animationSpeed);
    }
  }
  iconChanged() {
    if (!this._isReady) {
      return;
    }
    this.unregisterLottie();
    this.registerLottie();
  }
  async srcChanged() {
    if (this.src) {
      await loadIcon(this.src);
    }
    if (!this._isReady) {
      return;
    }
    this.unregisterLottie();
    this.registerLottie();
  }
  movePaletteToCssVariables() {
    for (const [key, value] of Object.entries(this.palette)) {
      this._root.querySelector(".body").style.setProperty(`--lord-icon-${key}-base`, value);
    }
  }
  get connectedTrigger() {
    return this._connectedTrigger;
  }
  get properties() {
    if (!this._properties && this.iconData) {
      this._properties = allProperties(this.iconData, true);
    }
    return this._properties || [];
  }
  get states() {
    return this.properties.filter((c) => c.name.startsWith(STATE_PREFIX)).map((c) => {
      return c.name.substr(STATE_PREFIX.length).toLowerCase();
    });
  }
  get defaultState() {
    const states = this.properties.filter((c) => c.name.startsWith(STATE_PREFIX) && c.value);
    if (states.length) {
      return states[0].name.substr(STATE_PREFIX.length).toLowerCase();
    }
    return void 0;
  }
  get isReady() {
    return this._isReady;
  }
  get lottie() {
    return this._lottie;
  }
  set palette(colors) {
    if (!colors || typeof colors !== "object") {
      return;
    }
    for (const current of this.properties) {
      if (current.type !== "color") {
        continue;
      }
      const name = current.name.toLowerCase();
      if (name in colors && colors[name]) {
        updateColor(this._lottie, this.properties, name, colors[name]);
      } else {
        resetColor(this._lottie, this.properties, name);
      }
    }
    this.refresh();
  }
  get palette() {
    if (!this._palette) {
      this._palette = new Proxy(this, {
        set: (target, property, value, receiver) => {
          for (const current of target.properties) {
            if (current.type == "color" && typeof property === "string" && property.toLowerCase() == current.name.toLowerCase()) {
              if (value) {
                updateColor(target._lottie, target.properties, property, value);
              } else if (value === void 0) {
                resetColor(target._lottie, target.properties, property);
              }
              target.refresh();
            }
          }
          return true;
        },
        get: (target, property, receiver) => {
          for (const current of target.properties) {
            if (current.type == "color" && typeof property === "string" && property.toLowerCase() == current.name.toLowerCase()) {
              return lottieColorToHex(get(target._lottie, current.path));
            }
          }
          return void 0;
        },
        deleteProperty: (target, property) => {
          for (const current of target.properties) {
            if (current.type == "color" && typeof property === "string" && property.toLowerCase() == current.name.toLowerCase()) {
              resetColor(target._lottie, target.properties, property);
              target.refresh();
            }
          }
          return true;
        },
        ownKeys: (target) => {
          return target.properties.filter((c) => c.type == "color").map((c) => c.name.toLowerCase());
        },
        has: (target, property) => {
          for (const current of target.properties) {
            if (current.type == "color" && typeof property === "string" && property.toLowerCase() == current.name.toLowerCase()) {
              return true;
            }
          }
          return false;
        },
        getOwnPropertyDescriptor: (target) => {
          return {
            enumerable: true,
            configurable: true
          };
        }
      });
    }
    return this._palette;
  }
  set icon(value) {
    if (value && isObjectLike(value)) {
      this._storedIconData = value;
      if (this.hasAttribute("icon")) {
        this.removeAttribute("icon");
      } else {
        this.iconChanged();
      }
    } else {
      const oldIconData = this._storedIconData;
      this._storedIconData = void 0;
      if (value) {
        this.setAttribute("icon", value);
      } else {
        this.removeAttribute("icon");
        if (oldIconData) {
          this.iconChanged();
        }
      }
    }
  }
  get icon() {
    return this._storedIconData || this.getAttribute("icon");
  }
  set src(value) {
    if (value) {
      this.setAttribute("src", value);
    } else {
      this.removeAttribute("src");
    }
  }
  get src() {
    return this.getAttribute("src");
  }
  set state(value) {
    if (value) {
      this.setAttribute("state", value);
    } else {
      this.removeAttribute("state");
    }
  }
  get state() {
    return this.getAttribute("state");
  }
  set colors(value) {
    if (value) {
      this.setAttribute("colors", value);
    } else {
      this.removeAttribute("colors");
    }
  }
  get colors() {
    return this.getAttribute("colors");
  }
  set trigger(value) {
    if (value) {
      this.setAttribute("trigger", value);
    } else {
      this.removeAttribute("trigger");
    }
  }
  get trigger() {
    return this.getAttribute("trigger");
  }
  set speed(value) {
    if (isNil(value)) {
      this.removeAttribute("speed");
    } else {
      this.setAttribute("speed", value);
    }
  }
  get speed() {
    if (this.hasAttribute("speed")) {
      return parseFloat(this.getAttribute("speed"));
    }
    return null;
  }
  set stroke(value) {
    if (isNil(value)) {
      this.removeAttribute("stroke");
    } else {
      this.setAttribute("stroke", value);
    }
  }
  get stroke() {
    if (this.hasAttribute("stroke")) {
      return parseFloat(this.getAttribute("stroke"));
    }
    return null;
  }
  set scale(value) {
    if (isNil(value)) {
      this.removeAttribute("scale");
    } else {
      this.setAttribute("scale", value);
    }
  }
  get scale() {
    if (this.hasAttribute("scale")) {
      return parseFloat(this.getAttribute("scale"));
    }
    return null;
  }
  set axisX(value) {
    if (isNil(value)) {
      this.removeAttribute("axis-x");
    } else {
      this.setAttribute("axis-x", value);
    }
  }
  get axisX() {
    if (this.hasAttribute("axis-x")) {
      return parseFloat(this.getAttribute("axis-x"));
    }
    return null;
  }
  set axisY(value) {
    if (isNil(value)) {
      this.removeAttribute("axis-y");
    } else {
      this.setAttribute("axis-y", value);
    }
  }
  get axisY() {
    if (this.hasAttribute("axis-y")) {
      return parseFloat(this.getAttribute("axis-y"));
    }
    return null;
  }
  get container() {
    return this._root.lastElementChild;
  }
  get iconData() {
    if (this.icon && typeof this.icon === "object") {
      return this.icon;
    }
    return getIcon(this.icon || this.src);
  }
  get animationSpeed() {
    if (this.hasAttribute("speed")) {
      const v = this.getAttribute("speed");
      return v === null ? 1 : parseFloat(v);
    }
    return 1;
  }
  get version() {
    return VERSION;
  }
};

// node_modules/lord-icon-element/build/triggers/base.js
var Base = class {
  constructor(element, lottie) {
    __publicField(this, "element");
    __publicField(this, "lottie");
    __publicField(this, "_inAnimation", false);
    __publicField(this, "_isReady", false);
    __publicField(this, "_connected", false);
    this.element = element;
    this.lottie = lottie;
    const lottieReady = () => {
      if (this._isReady) {
        return;
      }
      this._isReady = true;
      this.ready();
    };
    lottie.addEventListener("complete", () => {
      this._inAnimation = false;
      this.complete();
    });
    lottie.addEventListener("config_ready", lottieReady);
    if (this.lottie.isLoaded) {
      lottieReady();
    }
  }
  connectedCallback() {
    this._connected = true;
  }
  disconnectedCallback() {
    this._connected = false;
  }
  ready() {
  }
  complete() {
  }
  play() {
    this._inAnimation = true;
    this.lottie.play();
  }
  playFromBegining() {
    this._inAnimation = true;
    this.lottie.goToAndPlay(0);
  }
  stop() {
    this.lottie.stop();
  }
  goToFrame(frame) {
    this.lottie.goToAndStop(frame, true);
  }
  goToFirstFrame() {
    this.goToFrame(0);
  }
  goToLastFrame() {
    this.goToFrame(Math.max(0, this.lottie.getDuration(true) - 1));
  }
  setDirection(direction) {
    this.lottie.setDirection(direction);
  }
  setLoop(enabled) {
    this.lottie.loop = enabled;
  }
  setSpeed(speed) {
    this.lottie.setSpeed(speed);
  }
  get inAnimation() {
    return this._inAnimation;
  }
  get isReady() {
    return this._isReady;
  }
  get connected() {
    return this._connected;
  }
};

// node_modules/lord-icon-element/build/triggers/basic.js
var Basic = class extends Base {
  constructor() {
    super(...arguments);
    __publicField(this, "_events", []);
  }
  addTargetEventListener(event, callback) {
    const newEvent = typeof event == "string" ? { name: event } : event;
    const name = newEvent.name;
    this._events.push({ name, callback });
    this.targetElement.addEventListener(name, callback, newEvent.options);
  }
  clearAllTargetEventsListeners() {
    for (const event of this._events) {
      this.targetElement.removeEventListener(event.name, event.callback);
    }
    this._events = [];
  }
  disconnectedCallback() {
    this.clearAllTargetEventsListeners();
    super.disconnectedCallback();
  }
  get targetElement() {
    const element = this.element;
    const targetProperty = element.getAttribute("target");
    const target = targetProperty ? element.closest(targetProperty) : null;
    return target || element;
  }
};

// node_modules/lord-icon-element/build/triggers/click.js
var CLICK_EVENTS = [
  "mousedown",
  { name: "touchstart", options: { passive: true } }
];
var Click = class extends Basic {
  connectedCallback() {
    super.connectedCallback();
    for (const event of CLICK_EVENTS) {
      this.addTargetEventListener(event, () => {
        if (!this.inAnimation) {
          this.playFromBegining();
        }
      });
    }
  }
};

// node_modules/lord-icon-element/build/triggers/hover.js
var Hover = class extends Basic {
  connectedCallback() {
    super.connectedCallback();
    this.addTargetEventListener("mouseenter", () => {
      if (!this.inAnimation) {
        this.playFromBegining();
      }
    });
  }
};

// node_modules/lord-icon-element/build/triggers/morph.js
var Morph = class extends Basic {
  connectedCallback() {
    super.connectedCallback();
    this.addTargetEventListener("mouseenter", () => {
      this.setDirection(1);
      this.play();
    });
    this.addTargetEventListener("mouseleave", () => {
      this.setDirection(-1);
      this.play();
    });
  }
  disconnectedCallback() {
    this.setDirection(1);
    super.disconnectedCallback();
  }
};

// node_modules/lord-icon-element/build/triggers/loop-on-hover.js
var LoopOnHover = class extends Basic {
  constructor() {
    super(...arguments);
    __publicField(this, "playDelay", null);
    __publicField(this, "active", false);
  }
  connectedCallback() {
    super.connectedCallback();
    this.addTargetEventListener("mouseenter", () => {
      this.active = true;
      if (!this.inAnimation) {
        this.playFromBegining();
      }
    });
    this.addTargetEventListener("mouseleave", () => {
      this.active = false;
    });
  }
  disconnectedCallback() {
    this.resetPlayDelayTimer();
    super.disconnectedCallback();
  }
  complete() {
    this.resetPlayDelayTimer();
    if (!this.active || !this.connected) {
      return;
    }
    if (this.delay > 0) {
      this.playDelay = setTimeout(() => {
        this.playFromBegining();
      }, this.delay);
    } else {
      this.playFromBegining();
    }
  }
  resetPlayDelayTimer() {
    if (!this.playDelay) {
      return;
    }
    clearTimeout(this.playDelay);
    this.playDelay = null;
  }
  get delay() {
    const value = this.element.hasAttribute("delay") ? +(this.element.getAttribute("delay") || 0) : 0;
    return Math.max(value, 0);
  }
};

// node_modules/lord-icon-element/build/triggers/loop.js
var Loop = class extends Basic {
  constructor() {
    super(...arguments);
    __publicField(this, "playDelay", null);
  }
  ready() {
    this.play();
  }
  disconnectedCallback() {
    this.resetPlayDelayTimer();
    super.disconnectedCallback();
  }
  complete() {
    this.resetPlayDelayTimer();
    if (!this.connected) {
      return;
    }
    if (this.delay > 0) {
      this.playDelay = setTimeout(() => {
        this.playFromBegining();
      }, this.delay);
    } else {
      this.playFromBegining();
    }
  }
  resetPlayDelayTimer() {
    if (!this.playDelay) {
      return;
    }
    clearTimeout(this.playDelay);
    this.playDelay = null;
  }
  get delay() {
    const value = this.element.hasAttribute("delay") ? +(this.element.getAttribute("delay") || 0) : 0;
    return Math.max(value, 0);
  }
};

// node_modules/lord-icon-element/build/triggers/boomerang.js
var Boomerang = class extends Basic {
  connectedCallback() {
    super.connectedCallback();
    this.addTargetEventListener("mouseenter", () => {
      this.setDirection(1);
      this.play();
    });
  }
  disconnectedCallback() {
    this.setDirection(1);
    super.disconnectedCallback();
  }
  complete() {
    this.setDirection(-1);
    this.play();
  }
};

// node_modules/lord-icon-element/build/lord-icon-element.js
function defineLordIconElement(loader) {
  Element.registerAnimationLoader(loader);
  Element.registerTrigger("basic", Basic);
  Element.registerTrigger("click", Click);
  Element.registerTrigger("hover", Hover);
  Element.registerTrigger("loop", Loop);
  Element.registerTrigger("loop-on-hover", LoopOnHover);
  Element.registerTrigger("morph", Morph);
  Element.registerTrigger("boomerang", Boomerang);
  if (!customElements.get || !customElements.get("lord-icon")) {
    customElements.define("lord-icon", Element);
  }
}
export {
  Base as BaseTrigger,
  Basic as BasicTrigger,
  Boomerang as BoomerangTrigger,
  Click as ClickTrigger,
  Hover as HoverTrigger,
  LoopOnHover as LoopOnHoverTrigger,
  Loop as LoopTrigger,
  Element as LordIconElement,
  Morph as MorphTrigger,
  allProperties,
  defineLordIconElement,
  fromUnitVector,
  hexToLottieColor,
  hexToRgb,
  iconFeatures,
  lottieColorToHex,
  replaceProperty,
  resetColor,
  resetColors,
  resetProperty,
  rgbToHex,
  toUnitVector,
  updateColor,
  updateColors,
  updateProperty
};
//# sourceMappingURL=lord-icon-element.js.map
